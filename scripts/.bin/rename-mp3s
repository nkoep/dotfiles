#!/usr/bin/env python

import sys
import os
import re
import argparse
import struct

from mutagen import MutagenError
from mutagen.mp3 import MP3
from mutagen.id3 import ID3
from unidecode import unidecode


def die(msg):
    print(f"error: {msg}")
    sys.exit(1)


def parse_id3v1(path):
    with open(path, "rb") as f:
        f.seek(-128, os.SEEK_END)
        string = f.read(128)

    frames = ID3()
    try:
        tag, title, artist, album, year, _, track, genre = \
            struct.unpack("3s30s30s30s4s29sBB", string)
    except struct.error:
        return frames

    if tag != "TAG":
        return frames

    def fix_encoding(s):
        return s.split("\x00")[0].strip()

    title, artist, album, year, comment = list(map(
        fix_encoding, [title, artist, album, year, comment]))

    if title:
        frames["TIT2"] = id3.TIT2(text=title)
    if artist:
        frames["TPE1"] = id3.TPE1(text=[artist])
    if album:
        frames["TALB"] = id3.TALB(text=album)
    if year:
        frames["TDRC"] = id3.TDRC(text=year)
    if track and (track != 32 or string[-3] == "\x00"):
        frames["TRCK"] = id3.TRCK(text=str(track))
    if genre != 255:
        frames["TCON"] = id3.TCON(text=str(genre))
        frames["TCON"].text = frames["TCON"].genres

    return frames


def build_prefix(track, disc, include_disc):
    def split_and_convert(s):
        try:
            return int(s.split("/")[0])
        except (ValueError, IndexError, AttributeError):
            return ""
        return s
    track, disc = map(split_and_convert, (track, disc))
    if include_disc:
        return f"{disc}{track:02d}"
    return f"{track:02d}"


def clean_string(s):
    s = unidecode(s)
    s = re.sub("[\-/]", " ", s)
    fragments = s.split()
    fragments = map(lambda f: "and" if f == "&" else f, fragments)
    s = "_".join(fragments)
    s = re.sub("[^a-zA-Z0-9 _]", "", s)
    s = re.sub("[_]+", "_", s)
    return s


def build_filename(mp3, path, include_disc):
    tags = mp3.tags or id3.ID3()
    tags_id3v1 = None

    tag_mapping = {
        "TPE1": "artist",
        "TIT2": "title",
        "TRCK": "track_number",
        "TPOS": "disc_number",
        "TPE2": "album_artist",
        "TALB": "album",
        "TDRC": "date"
    }
    values = {}
    for tag, attr in tag_mapping.items():
        try:
            frame = tags.getall(tag)[0]
        except IndexError:
            if tags_id3v1 is None:
                tags_id3v1 = parse_id3v1(path)
            try:
                frame = tags_id3v1.getall(tag)[0]
            except IndexError:
                continue
        value = frame.text
        values[attr] = value[0]

    prefix = build_prefix(
        values.get("track_number"), values.get("disc_number"), include_disc)
    artist = clean_string(values.get("artist")).lower()
    title = clean_string(values.get("title")).lower()
    album_artist = values.get("album_artist") or values.get("artist")
    album_title = values.get("album")
    try:
        date = values.get("date").get_text()
    except AttributeError:
        date = ""

    return f"{prefix}-{artist}-{title}.mp3", album_artist, album_title, date


def rename_files(directory, mapping):
    for newname, oldname in sorted(mapping.items(), key=lambda v: v[0]):
        os.rename(
            *map(lambda f: os.path.join(directory, f), (oldname, newname)))


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("directory", nargs=1, help="target directory")
    parser.add_argument("-d", help="include disc prefix", default=False,
                        required=False, action="store_true",
                        dest="include_disc")
    return vars(parser.parse_args())


def determine_folder_name(album_artists, album_titles, dates):
    if len(album_artists) == 1:
        album_artist = album_artists.pop()
    else:
        album_artist = "VA"
    if len(album_titles) > 1:
        die("Album title is not unique")
    album_title = album_titles.pop()
    if len(dates) > 1:
        die("Year is not unique")
    date = dates.pop()
    return f"{clean_string(album_artist)}-{clean_string(album_title)}-{date}"


def canonicalize_path(p):
    return os.path.realpath(os.path.expanduser(p))


def main():
    args = parse_args()

    directory = args["directory"][0]
    if not os.path.isdir(directory):
        die(f"'{directory} is not a directory")
    directory = canonicalize_path(directory)

    tracks = {}
    for f in os.listdir(directory):
        try:
            mp3 = MP3(os.path.join(directory, f))
        except MutagenError as exc:
            print(f"Skipping file '{f}': {exc}")
            continue
        tracks[f] = mp3

    mapping = {}
    album_artists = set()
    album_titles = set()
    dates = set()
    for f in sorted(tracks.keys()):
        audio = tracks[f]
        filename, album_artist, album_title, date = build_filename(
            audio, os.path.join(directory, f),
            include_disc=args["include_disc"])
        album_artists.add(album_artist)
        album_titles.add(album_title)
        dates.add(date)
        mapping[filename] = f

    print()
    if not mapping:
        print("No mp3s found")
        sys.exit(0)

    header = "New filenames:"
    print(header)
    print("-" * len(header))
    print()
    for newname, oldname in sorted(mapping.items(), key=lambda v: v[0]):
        print(f"{oldname}   →   {newname}")
    print()

    def prompt_action(question, callback):
        answer = input(f"{question} [Y/n] ").lower() or "y"
        if answer == "y":
            callback()
            print("Done")
            return True
        print()
        return False

    prompt_action("Rename files?",
                  lambda: rename_files(directory, mapping))

    dirname = os.path.dirname(directory)
    basename = os.path.basename(directory)
    new_directory = determine_folder_name(album_artists, album_titles, dates)

    def rename_directories():
        if os.getcwd() == directory:
            die("Cannot rename working directory")
        os.rename(directory, os.path.join(dirname, new_directory))
    prompt_action(f"Rename directories: '{basename}'   →   '{new_directory}'?",
                  rename_directories)


if __name__ == "__main__":
    main()
